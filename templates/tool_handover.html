{% extends "home.html" %}
{% block title %}Handover Tool{% endblock %}
{% block content %}

<script>
  window.API_BASE = window.API_BASE || "";
</script>

<!-- ===== Notice ===== -->
<div id="notice" class="notice"></div>

<!-- ===== Controls (mới) ===== -->
<div id="controls">
  <label>Channel:</label>
  <div id="channelGroup" class="btn-group" data-active="SPX">
    <button type="button" data-val="SPX" class="btn-toggle active">SPX</button>
    <button type="button" data-val="GHN" class="btn-toggle">GHN</button>
  </div>

  <div class="row">
    <input id="userName" type="text" placeholder="Nhập tên người bàn giao" spellcheck="false">
    <input id="orderId" type="text" placeholder="Nhập mã vận đơn (Enter để Scan)" spellcheck="false">
  <button id="btnNextBatch" class="btn-action">Next batch</button>
  <button id="btnReport" class="btn-report">Export Excel</button>
  </div>

  <!-- ===== Report + Delete ===== -->
  <div id="reporting">
    <input id="deleteBox" type="text" placeholder="Nhập mã đơn cần xoá" spellcheck="false">
    <button id="btnDelete" class="btn-action btn-danger">Delete</button>
  </div>
</div>

  <!-- Date selector -->
  <div class="row mt-2">
    <label>Ngày:</label>
    <input id="datePicker" type="date">
    <input id="searchBox" type="text" placeholder="Tìm theo mã đơn/user..." spellcheck="false">
    <button id="btnSearch" class="btn-action">Search</button>
    <button id="btnReset" class="btn-action">Reset</button>
  </div>

<!-- ===== Dual Tables: Cancel (left) & Scan (right) ===== -->
<div id="tablesWrap">
  <!-- CANCEL TABLE (bên trái) -->
  <section id="cancelSection">
    <div class="row" style="margin-bottom:6px">
      <h3>
  Đơn Huỷ <span id="cancelCountsHdr"></span>
  </h3>
          <div class="row ml-auto">
        <button id="cancelPrev">«</button>
        <span id="cancelPageDisplay">1/1</span>
        <button id="cancelNext">»</button>
      </div>
    </div>
    <div class="table-scroll card" style="padding:0">
      <table id="tblCancel">
        <thead>
          <tr>
            <th>No.</th>
            <th>Mã Đơn</th>
            <th>Scan Time</th>
            <th>User</th>
            <th>Is_Canceled</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- SCAN TABLE (bên phải) -->
  <section id="scanSection">
  <div class="row" style="margin-bottom:6px">
  <h3>
        <!-- SCAN -->
        <span id="scanStats" class="scan-stats"></span>
      </h3>
  <div class="row ml-auto">
        <button id="scanPrev">«</button>
        <span id="scanPageDisplay">1/1</span>
        <button id="scanNext">»</button>
      </div>
    </div>

    <div class="table-scroll card" style="padding:0">
      <table id="tblScan">
        <thead>
          <tr>
            <th>No.</th>
            <th>Mã Đơn</th>
            <th>Scan Time</th>
            <th>User</th>
            <th>Is_Canceled</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>
</div>

<!-- Inline responsive CSS removed; using static/css/main.css -->

<!-- ===== Firebase SDKs ===== -->
<script type="module">
  // Import modular Firebase configuration
  import { initFirebase } from '../static/js/firebase-config.js';

  // Initialize Firebase for handover project
  const { app, db, ref, get, set, remove, onValue, goOffline, goOnline, databaseURL } = await initFirebase('handover');

  // ✅ DB instance chuẩn

  // (tuỳ chọn) Tiết kiệm connection khi tab ẩn
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) goOffline(db); else goOnline(db);
  });
  window.addEventListener("beforeunload", () => goOffline(db));

  // === Date helpers (GMT+7) ===
  const todayISO = () => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${dd}`;         // YYYY-MM-DD (cho <input type="date">)
  };
  const isoToKey = (iso) => {
    // YYYY-MM-DD -> DD-MM-YYYY (đang dùng trên Firebase)
    if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return today(); // fallback
    const [y,m,d] = iso.split("-");
    return `${d}-${m}-${y}`;
  };
  const keyToISO = (key) => {
    // DD-MM-YYYY -> YYYY-MM-DD
    if (!key || !/^\d{2}-\d{2}-\d{4}$/.test(key)) return todayISO();
    const [d,m,y] = key.split("-");
    return `${y}-${m}-${d}`;
  };
  const isSameDay = (isoA, isoB) => isoA === isoB;

  // === Selected day state ===
  const $ = sel => document.querySelector(sel);
  const today = () => {
    const d = new Date();
    const dd = String(d.getDate()).padStart(2,"0");
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const yyyy = d.getFullYear();
    return `${dd}-${mm}-${yyyy}`;
  };
  const formatVN = (d) => {
    // chuẩn hoá GMT+7 bằng toLocaleString với timeZone Asia/Ho_Chi_Minh
    return new Date(d).toLocaleString("vi-VN", { timeZone: "Asia/Ho_Chi_Minh" }).replace(",", "");
  };

  let SELECTED_KEY = today();       // DD-MM-YYYY (đường dẫn Firebase)
  let SELECTED_ISO = todayISO();    // YYYY-MM-DD (UI date input)

  function formatISO(ts) {
  const d = new Date(ts);
  // buộc timezone Asia/Ho_Chi_Minh
  const y = d.getFullYear();
  const M = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");
  const ss = String(d.getSeconds()).padStart(2, "0");
  return `${y}-${M}-${dd} ${hh}:${mm}:${ss}`;
}

  const notice = (msg, kind="info", timeout=0) => {
    const bar = $("#notice");
    if (!bar) return;

    // Clear previous classes and styles
    bar.className = "notice";
    bar.removeAttribute("data-kind");

    if (msg) {
      bar.setAttribute("data-kind", kind);
      bar.textContent = msg;

      // Chỉ tự động xóa nếu timeout > 0 và không phải là error
      if (timeout > 0 && kind !== "error") {
        setTimeout(() => {
          if (bar.textContent === msg) { // Chỉ xóa nếu nội dung chưa thay đổi
            bar.textContent = "";
            bar.removeAttribute("data-kind");
          }
        }, timeout);
      }
    } else {
      bar.textContent = "";
    }
  };  // ===== State =====
  let ALL_EVENTS = {};     // { DATA_SCAN, Data-cancel }
  let CANCEL_MAP = {};     // TRACKING -> { cancel_time, channel }
  let currentBatchByCh = { SPX:1, GHN:1, NJV:1 };

  // UI refs
  const el = {
    chanGroup: document.getElementById("channelGroup"),
    user: $("#userName"),
    order: $("#orderId"),
    btnNextBatch: $("#btnNextBatch"),
    searchBox: $("#searchBox"),
    btnSearch: $("#btnSearch"),
    deleteBox: $("#deleteBox"),
    btnDelete: $("#btnDelete"),
  };

  // Date picker
  el.datePicker = document.getElementById("datePicker");
  el.btnLoadDay = document.getElementById("btnLoadDay");

  const selectedChannel = () => (el.chanGroup.dataset.active || "SPX");

  function bindToggle(groupEl, onChange){
    groupEl.addEventListener("click", (e)=>{
      const btn = e.target.closest(".btn-toggle");
      if(!btn) return;
      groupEl.querySelectorAll(".btn-toggle").forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      groupEl.dataset.active = btn.dataset.val;
      onChange && onChange();
    });
  }

 // ===== MODULAR SOUND SYSTEM =====
let playOk, playErr, playCancel, playSysOk, playSysErr;

// Dynamic import for sound system with Flask-built URLs
(async () => {
  try {
    const soundModule = await import('../static/js/sound-system.js');
    const STATIC_AUDIO_URLS = {
      "cancel.mp3":      "{{ url_for('static', filename='sounds/cancel.mp3') }}",
      "error.mp3":       "{{ url_for('static', filename='sounds/error.mp3') }}",
      "ok.mp3":          "{{ url_for('static', filename='sounds/ok.mp3') }}",
      "sys_error.mp3":   "{{ url_for('static', filename='sounds/sys_error.mp3') }}",
      "sys_success.mp3": "{{ url_for('static', filename='sounds/sys_success.mp3') }}"
    };
    await soundModule.initSounds(STATIC_AUDIO_URLS);
    playOk = soundModule.playOk;
    playErr = soundModule.playErr;
    playCancel = soundModule.playCancel;
    playSysOk = soundModule.playSysOk;
    playSysErr = soundModule.playSysErr;
  } catch (e) {
    console.warn('Failed to load sound system:', e);
    // Fallback to simple beep
    const fallbackBeep = () => console.beep?.() || console.log('beep');
    playOk = playErr = playCancel = playSysOk = playSysErr = fallbackBeep;
  }
})();

// Reset về mặc định (SPX / hôm nay / page 1)
function resetAll(){
  // reset channel về SPX
  const chGroup = el.chanGroup;
  if (chGroup){
    chGroup.dataset.active = "SPX";
    chGroup.querySelectorAll(".btn-toggle").forEach(b => {
      b.classList.toggle("active", b.dataset.val==="SPX");
    });
  }

  // reset input
  if (el.user) el.user.value = "";
  if (el.order) el.order.value = "";
  if (el.searchBox) el.searchBox.value = "";
  if (el.deleteBox) el.deleteBox.value = "";

  // reset date về hôm nay
  SELECTED_ISO = todayISO();
  SELECTED_KEY = today();
  if (el.datePicker) el.datePicker.value = SELECTED_ISO;

  // Rebind realtime listeners to the new (today) key
  try { bindAllListenersFor(SELECTED_KEY); } catch (e) { console.warn("[resetAll] bindAllListenersFor failed", e); }

  // Re-render after rebinding
  renderBoth();

  // nhảy về trang cuối cùng của SPX
  const totalPages = getScanTotalPages();
  scanPageIndex = totalPages;
  setScanPage(scanPageIndex);

  const cancelTotalPages = getCancelTotalPages();
  cancelPageIndex = cancelTotalPages;
  setCancelPage(cancelPageIndex);

  // cập nhật enable/disable theo ngày đang chọn (hôm nay) + trạng thái mạng
  applyHistoricalMode();

  notice("Đã reset: Channel SPX / Hôm nay / Trang cuối", "success", 4000);
}

const btnReset = document.getElementById("btnReset");
if (btnReset) btnReset.addEventListener("click", resetAll);

/* sound unlock and playback handled by sound-system.js */

// ===== Report (text + file) =====
async function postJSON(url, body){
  const base = (window.API_BASE || "");                 // "" => same origin
  const r = await fetch(base + url, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body)
  });
  if(!r.ok) throw new Error(await r.text());
  return r.json().catch(()=> ({}));
}

// Export Excel đa sheet theo format Seatalk (SPX, GHN) + thêm sheet Cancel (cả 2 kênh)
function fitCols(headers, rows){
  return headers.map((h, i) => ({
    wch: Math.max(
      String(h || "").length + 2,
      ...rows.map(r => String(r[i] || "").length + 1)
    )
  }));
}

function buildChannelRows(ch){
  const dataCh = (ALL_EVENTS["DATA_SCAN"]?.[ch]) || {};
  // Lọc bỏ đơn Cancel để giống thống kê non-cancel trong message
  const items = Object.entries(dataCh)
    .filter(([id, ev]) => (ev?.is_cancelled || "No") !== "Yes")
    .map(([id, ev]) => {
      const ts = Number(ev?.ts || 0) || parseTimeString(ev?.time_vn) || parseTimeString(ev?.time);
      const timeText = ev?.time_vn || (ts ? formatISO(ts * 1000) : (ev?.time || ""));
      return { id, user: ev?.user || "", ts, timeText };
    })
    .sort((a,b)=> b.ts - a.ts);

  const headers = ["STT", "Scan Time", "LM Tracking", "Người Bàn Giao"];
  const rows = items.map((it, idx) => [idx + 1, it.timeText, it.id, it.user]);
  return { headers, rows };
}

function buildCancelAllRows(){
  const rawCancel = ALL_EVENTS["Data-cancel"] || {};
  const scanAll   = ALL_EVENTS["DATA_SCAN"] || {};
  const acc = [];

  for (const ch of Object.keys(rawCancel)){
    const cancelCh = rawCancel[ch] || {};
    const scanCh   = scanAll[ch] || {};
    for (const id of Object.keys(cancelCh)){
      const evScan = scanCh[id] || {};
      const cancel_time = Number(cancelCh[id]?.cancel_time || 0) || 0;
      const scan_ts = Number(evScan?.ts || 0) || parseTimeString(evScan?.time_vn) || parseTimeString(evScan?.time) || 0;
      const scanText = evScan?.time_vn || (scan_ts ? formatISO(scan_ts * 1000) : (evScan?.time || ""));
      acc.push({ id, ch, cancel_time, scan_ts, scanText, user: evScan?.user || "" });
    }
  }

  acc.sort((a,b)=> (b.cancel_time || b.scan_ts) - (a.cancel_time || a.scan_ts));

  const headers = ["STT", "LM Tracking", "Cancel Time", "Scan Time", "Người Bàn Giao", "Channel"];
  const rows = acc.map((it, idx) => [
    idx + 1,
    it.id,
    it.cancel_time ? formatISO(it.cancel_time * 1000) : "",
    it.scanText,
    it.user,
    it.ch
  ]);
  return { headers, rows };
}

function exportHandoverXLSX(){
  try{
    const { headers: hSPX, rows: rSPX } = buildChannelRows("SPX");
    const { headers: hGHN, rows: rGHN } = buildChannelRows("GHN");
    const { headers: hC,   rows: rC   } = buildCancelAllRows();

    const wsSPX = XLSX.utils.aoa_to_sheet([hSPX, ...rSPX]);
    const wsGHN = XLSX.utils.aoa_to_sheet([hGHN, ...rGHN]);
    const wsCAN = XLSX.utils.aoa_to_sheet([hC,   ...rC  ]);

    wsSPX['!cols'] = fitCols(hSPX, rSPX);
    wsGHN['!cols'] = fitCols(hGHN, rGHN);
    wsCAN['!cols'] = fitCols(hC,   rC  );

    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, wsSPX, "SPX");
    XLSX.utils.book_append_sheet(wb, wsGHN, "GHN");
    XLSX.utils.book_append_sheet(wb, wsCAN, "Cancel");

    const totalNonCancel = rSPX.length + rGHN.length;
    const filename = `DataHandover_${SELECTED_KEY} - ${totalNonCancel}.xlsx`;
    XLSX.writeFile(wb, filename);
    playSysOk();
    notice(`✅ Đã xuất Excel: ${filename}`, "success", 6000);
  }catch(e){
    console.error(e);
    playSysErr();
    notice("❌ Xuất Excel lỗi: " + (e.message||e), "error", 8000);
  }
}

document.getElementById("btnReport").addEventListener("click", exportHandoverXLSX);

function applyHistoricalMode(){
  const isToday = isSameDay(SELECTED_ISO, todayISO());

  // Cho phép Search + Report mọi lúc
  el.searchBox.disabled = false;
  el.btnSearch.disabled = false;
  document.getElementById("btnReport").disabled = false;

  // Nếu KHÔNG phải hôm nay -> khóa các tác vụ ghi
  const lock = !isToday || !connected;
  // Scan + Delete + Next batch
  el.order.disabled = lock;
  el.btnDelete.disabled = lock;
  el.deleteBox.disabled = lock;
  el.btnNextBatch.disabled = lock;

  // Nhóm toggle channel/mode và paging vẫn bật để duyệt dữ liệu
  el.chanGroup?.querySelectorAll("button").forEach(b => b.disabled = false);
  el.modeGroup?.querySelectorAll("button").forEach(b => b.disabled = false);

  if (el.btnPrev) el.btnPrev.disabled = false;
  if (el.btnNext) el.btnNext.disabled = false;
  if (el.page)    el.page.disabled    = false;


  // Thông báo
  if (!isToday) {
    notice(`Đang xem dữ liệu ngày ${SELECTED_KEY}. Chế độ chỉ đọc (Search/Report).`, "warning", 6000);
  }
}

// Auto-load khi đổi ngày trên datePicker
el.datePicker.addEventListener("change", () => {
  const pickISO = el.datePicker.value || todayISO();

  // Nếu không đổi ngày thì thôi
  if (pickISO === SELECTED_ISO) return;

  // Cập nhật state ngày
  SELECTED_ISO = pickISO;
  SELECTED_KEY = isoToKey(pickISO);

  // Reset paging về trang 1 cho cả hai bảng
  scanPageIndex = 1;
  cancelPageIndex = 1;
  setScanPage(1);
  setCancelPage(1);

  // Gắn lại listeners theo ngày mới
  bindAllListenersFor(SELECTED_KEY);
  // Bật/tắt input theo ngày & mạng
  applyHistoricalMode();
  // Render lại
  renderBoth();
});

// Khi trạng thái kết nối đổi, vẫn giữ nguyên rule theo ngày
const _origWatchConnectivity = watchConnectivity;

el.datePicker.value = SELECTED_ISO;
let pageIndex = 1;
let connected = false;

  // chống spam & trùng trong phiên
  let isSubmitting = false;
  const PENDING_SET = new Set();              // id đang submit (chưa xong)
  const LOCAL_SEEN  = new Map();              // key = `${today()}|${ch}` -> Set(ids)

  function _seenKey(ch){ return `${today()}|${ch}`; }
  function _getSeen(ch){
    const k = _seenKey(ch);
    if (!LOCAL_SEEN.has(k)) LOCAL_SEEN.set(k, new Set());
    return LOCAL_SEEN.get(k);
}

  const setInputsEnabled = (on) => {
  const disabled = !on;
  [el.order, el.btnNextBatch,el.searchBox, el.btnSearch, el.deleteBox, el.btnDelete].forEach(x => x && (x.disabled = disabled));

  // disable các nút trong nhóm toggle
  el.chanGroup?.querySelectorAll("button").forEach(b => b.disabled = disabled);
};

// ===== BẮT LỖI TOÀN CỤC + DẤU VẾT BOOT =====
console.log("[BOOT] handover module start");
window.addEventListener("error", e => console.error("[GlobalError]", e.message, e.filename, e.lineno, e.error));
window.addEventListener("unhandledrejection", e => console.error("[PromiseRejection]", e.reason));

// 🔌 Theo dõi kết nối Firebase (bao gồm mất mạng)
// ✅ dùng function declaration để được hoisted
// ---- helpers ----
function pick(...ids){
  for (const id of ids){
    const el = document.getElementById(id);
    if (el) return el;
  }
  return null;
}

// ---- functions (dùng function declaration để hoisted) ----
function watchConnectivity() {
  const infoRef = ref(db, ".info/connected");
  onValue(infoRef, snap => {
    connected = !!snap.val();
    if (!connected) notice("Mất kết nối Firebase. Vui lòng kiểm tra mạng…", "error", 0);
    else notice("Đã kết nối Firebase.", "success", 1500);
    applyHistoricalMode();
  });
}

/* ==== RENDER & DATA HELPERS ==== */
const PAGE_SIZE = 100;

// hoist 1 lần ở trên
function parseTimeString(s){
  try{
    const str = String(s||"").trim();

    // ISO-like: YYYY-MM-DD HH:mm:ss
    let m = str.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
    if (m) {
      const [_, y, M, d, h, m1, s1] = m.map(Number);
      return Math.floor(new Date(y, M-1, d, h, m1, s1).getTime()/1000);
    }

    // VN-like: DD-MM-YYYY HH:mm:ss
    m = str.match(/^(\d{2})-(\d{2})-(\d{4})[ T](\d{2}):(\d{2}):(\d{2})$/);
    if (m) {
      const [_, d, M, y, h, m1, s1] = m.map(Number);
      return Math.floor(new Date(y, M-1, d, h, m1, s1).getTime()/1000);
    }
  }catch(e){/* no-op */}
  return 0;
}

// helper chung
function paginate(total, pageSize, reqPage){
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  const page = Math.min(Math.max(1, Number(reqPage || 1)), totalPages);
  const start = (page - 1) * pageSize;          // 0-based
  const end   = Math.min(start + pageSize, total);
  const count = end - start;                     // số dòng thực sự hiển thị
  const noStart = total - start;                 // STT đầu trang (giảm dần)
  return { totalPages, page, start, end, count, noStart };
}

function getScanRows(){
  const ch = selectedChannel();
  const data = (ALL_EVENTS["DATA_SCAN"]?.[ch]) || {};
  const rows = [];
  for (const [id, v] of Object.entries(data)){
    let ts = Number(v.ts||0);
    if (!ts && v.time) ts = parseTimeString(v.time);
    rows.push([id, {
      ts,                                  // scan_ts
      time_vn: v.time_vn || v.time || (ts ? formatISO(ts*1000) : ""),
      user: v.user || "",
      is_cancelled: v.is_cancelled || "No",
      batch_id: v.batch_id || "",
    }]);
  }
  return rows;
}

function getScanTotalPages(){
  const rows = (typeof applySearch==="function") ? applySearch(getScanRows()) : getScanRows();
  return Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
}

function getCancelRows(){
  const ch = selectedChannel();
  const cancelSrc = (ALL_EVENTS["Data-cancel"]?.[ch]) || {};
  const scanData  = (ALL_EVENTS["DATA_SCAN"]?.[ch]) || {};

  const rows = [];
  for (const id of Object.keys(cancelSrc)) {
    const evScan = scanData[id] || {};   // nếu chưa scan thì object rỗng
    let scan_ts = Number(evScan.ts||0);
    if (!scan_ts && evScan.time) scan_ts = parseTimeString(evScan.time);

    rows.push([id, {
      cancel_time: Number(cancelSrc[id]?.cancel_time) || 0,
      scan_ts,
      time_vn: evScan.time_vn || evScan.time || "",
      user: evScan.user || "",
      // ✅ chỉ lấy is_cancelled nếu có bản ghi SCAN, nếu chưa scan => để ""
      is_cancelled: (Object.keys(evScan).length > 0) ? (evScan.is_cancelled || "No") : "",
      batch_id: evScan.batch_id || "",
    }]);
  }
  return rows;
}

function applySearch(rows){
  const q = (el.searchBox.value || "").trim().toUpperCase();
  if (!q) return rows;
  return rows.filter(([id, ev]) =>
    id.toUpperCase().includes(q) ||
    (ev.user||"").toUpperCase().includes(q)
  );
}

/* =========================
   RENDER 2 BẢNG
========================= */
const el2 = {
  tblScanBody   : document.querySelector("#tblScan tbody"),
  tblCancelBody : document.querySelector("#tblCancel tbody"),
  scanPrev      : document.getElementById("scanPrev"),
  scanNext      : document.getElementById("scanNext"),
  cancelPrev    : document.getElementById("cancelPrev"),
  cancelNext    : document.getElementById("cancelNext"),
  scanPageDisp  : document.getElementById("scanPageDisplay"),
  cancelPageDisp: document.getElementById("cancelPageDisplay"),
};

let scanPageIndex   = 1;
let cancelPageIndex = 1;

const currentBatch = () => Number(currentBatchByCh[selectedChannel()] || 1);

// ===== Submit scan (GMT+7 + sound + prefix) =====
  const prefixByCh = {
  SPX: { prefix: "SPX", len: 17 },   // 3 + 14 ký tự
  GHN: { prefix: "G",   len: 8  },   // 1 + 7 ký tự
  NJV: { prefix: "SPE", len: null }  // chưa giới hạn
};

  const submitScan = async () => {
    if (!connected) { playErr(); notice("Chưa kết nối Firebase!", "error", 3000); return; }

    const user = (el.user.value || "").trim();
    const id   = (el.order.value || "").trim().toUpperCase();
    const ch   = selectedChannel();

    if (!user) {
      playErr();
      notice("⚠️ Tên người bàn giao không được để trống!", "warning", 3000);
      el.order.value = "";
      el.user.focus();
      return;
    }
    if (!id) return;

    const rule = prefixByCh[ch] || {};
    const prefix = rule.prefix || "";
    const maxLen = rule.len;

    // check prefix
    if (!id.startsWith(prefix)) {
      playErr();
      notice(`❗ Đơn ${id} không thuộc Channel ${ch}.`, "error", 3000);
      el.order.value = "";
      el.order.focus();
      return;
    }

    // check length nếu có quy định
    if (maxLen && id.length > maxLen) {
      playErr();
      notice(`❗ ${ch} chỉ cho phép tối đa ${maxLen} ký tự (hiện ${id.length}).`, "error", 3000);
      el.order.value = "";
      el.order.focus();
      return;
    }

    const node = `/${today()}/DATA_SCAN/${ch}/${id}`;
    const snap = await get(ref(db, node));
    if (snap.exists()) {
      playErr();
      notice(`❗ Đơn ${id} đã được quét trước đó.`, "warning", 3000);
      el.order.value = "";
      el.order.focus();
      return;
    }

    // CANCEL check
    const isCancelled = (CANCEL_MAP[id]?.channel?.toUpperCase() === ch) ? "Yes" : "No";
    const nowTs = Math.floor(Date.now()/1000);
    const payload = {
      ts: nowTs,                                      // epoch seconds (để sort)
      // time_vn: formatVN(nowTs*1000),                  // hiển thị chuẩn GMT+7
      time_vn: formatISO(nowTs*1000),                 // hiển thị chuẩn YYYY-MM-DD HH:mm:ss
      user,
      is_cancelled: isCancelled,
      source: "webapp",
      batch_id: currentBatch()
    };
    await set(ref(db, node), payload);

    if (isCancelled==="Yes") {
    playCancel();                             // ⬅️ thay vì playErr()
    notice(`${id} - ĐƠN CANCEL`, "warning", 6000);
    } else {
      playOk();
      notice(`✅ ${id}`, "success", 1500);
    }
    el.order.focus();
    el.order.value = "";
  };

  // ===== Next batch =====
  const doNextBatch = async () => {
    if (!connected) { playErr(); notice("Chưa kết nối Firebase!", "error", 3000); return; }
    const ch = selectedChannel();
    const node = `/${today()}/BATCH/${ch}`;
    const cur  = (await get(ref(db, node))).val() || 1;
    await set(ref(db, node), Number(cur)+1);
    el.order.focus();
  };

  // ===== Delete =====
  const doDelete = async () => {
    if (!connected) {
      playErr();
      notice("Chưa kết nối Firebase!", "error", 3000);
      return;
    }

    const id = (el.deleteBox.value||"").trim().toUpperCase();
    if (!id) return;

    const ch = selectedChannel();
    const node = `/${today()}/DATA_SCAN/${ch}/${id}`;
    const snap = await get(ref(db, node));

    // 1. Nếu không có đơn => báo luôn
    if (!snap.exists()) {
      playErr();
      notice(`Không tìm thấy đơn ${id} để xoá.`, "warning", 2500);
      el.deleteBox.value = "";
      return;
    }

    // 2. Nếu có đơn => popup confirm
    if (!window.confirm(`Bạn có chắc chắn muốn xoá đơn ${id}?`)) {
      return; // user Cancel thì thôi
    }

    // 3. Thực hiện xoá
    await remove(ref(db, node));
    playOk();
    notice(`🗑️ Đã xoá ${id}`, "success", 2000);
    el.deleteBox.value = "";
  };

// state
const scanStateByCh = {
  SPX: { prevTotalPages: 1, userTouched: false },
  GHN: { prevTotalPages: 1, userTouched: false },
};

// helper
const on = (el, ev, fn) => el && el.addEventListener(ev, fn);
const toInt = v => Math.max(1, parseInt(v, 10) || 1);

// Helper functions to update pagination without re-rendering
function updateScanPagination() {
  const totalPages = getScanTotalPages();
  if (el2.scanPageDisp) el2.scanPageDisp.textContent = `${scanPageIndex}/${totalPages}`;

  if (scanPageIndex === 1 && totalPages === 1) {
    if (el2.scanPrev) el2.scanPrev.disabled = true;
    if (el2.scanNext) el2.scanNext.disabled = true;
  } else if (scanPageIndex === 1 && scanPageIndex < totalPages) {
    if (el2.scanPrev) el2.scanPrev.disabled = true;
    if (el2.scanNext) el2.scanNext.disabled = false;
  } else if (scanPageIndex === totalPages && scanPageIndex > 1) {
    if (el2.scanPrev) el2.scanPrev.disabled = false;
    if (el2.scanNext) el2.scanNext.disabled = true;
  } else {
    if (el2.scanPrev) el2.scanPrev.disabled = false;
    if (el2.scanNext) el2.scanNext.disabled = false;
  }
}

function updateCancelPagination() {
  const totalPages = getCancelTotalPages();
  if (el2.cancelPageDisp) el2.cancelPageDisp.textContent = `${cancelPageIndex}/${totalPages}`;

  if (cancelPageIndex === 1 && totalPages === 1) {
    if (el2.cancelPrev) el2.cancelPrev.disabled = true;
    if (el2.cancelNext) el2.cancelNext.disabled = true;
  } else if (cancelPageIndex === 1 && cancelPageIndex < totalPages) {
    if (el2.cancelPrev) el2.cancelPrev.disabled = true;
    if (el2.cancelNext) el2.cancelNext.disabled = false;
  } else if (cancelPageIndex === totalPages && cancelPageIndex > 1) {
    if (el2.cancelPrev) el2.cancelPrev.disabled = false;
    if (el2.cancelNext) el2.cancelNext.disabled = true;
  } else {
    if (el2.cancelPrev) el2.cancelPrev.disabled = false;
    if (el2.cancelNext) el2.cancelNext.disabled = false;
  }
}

// Scan
function setScanPage(n){
  const totalPages = getScanTotalPages();
  scanPageIndex = Math.min(Math.max(1, Number(n)||1), totalPages);
  updateScanPagination();
  renderScan();
}
on(el2?.scanPrev, "click", () => setScanPage(scanPageIndex - 1));
on(el2?.scanNext, "click", () => setScanPage(scanPageIndex + 1));

// Cancel
function getCancelTotalPages(){
  const totalRows = getCancelRows().length;
  return Math.max(1, Math.ceil(totalRows / PAGE_SIZE));
}
function setCancelPage(n){
  const totalPages = getCancelTotalPages();
  cancelPageIndex = Math.min(Math.max(1, Number(n)||1), totalPages);
  updateCancelPagination();
  renderCancel();
}
on(el2?.cancelPrev, "click", () => setCancelPage(cancelPageIndex - 1));
on(el2?.cancelNext, "click", () => setCancelPage(cancelPageIndex + 1));
console.log('scanPrev:', !!el2?.scanPrev, 'scanNext:', !!el2?.scanNext);

// ===== Render bảng Scan =====

// Tính lát cắt
function scanSliceBounds(total, pageSize, pageIndex){
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  const rem = total % pageSize;

  // Không dư: các trang đều đủ pageSize
  if (rem === 0) {
    const end   = pageIndex * pageSize;
    const start = end - pageSize;
    return { start, end };
  }

  // Có dư: last page (page = totalPages) là phần dư (rem),
  // các trang trước đó đều đủ pageSize và nằm TRƯỚC phần dư.
  if (pageIndex === totalPages) {
    const start = total - rem;
    const end   = total;
    return { start, end };
  } else {
    // Số trang nằm "sau" trang hiện tại (tính tới last page)
    const blocksAfter = (totalPages - pageIndex);
    const end   = total - rem - (blocksAfter - 0) * pageSize; // hoặc: total - rem - (blocksAfter * pageSize)
    const start = end - pageSize;
    return { start, end };
  }
}

function renderScan(){
  const rows = getScanRows();
  const rowsFiltered = (typeof applySearch==="function") ? applySearch(rows) : rows;

  // === Sort A→Z (cũ → mới) để đuôi là mới nhất ===
  rowsFiltered.sort((a,b)=>{
    const tsA = Number(a[1].ts||0) || parseTimeString(a[1].time_vn) || parseTimeString(a[1].time);
    const tsB = Number(b[1].ts||0) || parseTimeString(b[1].time_vn) || parseTimeString(b[1].time);
    return tsA - tsB;  // A→Z
  });

  const total = rowsFiltered.length;
  const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));

  // cập nhật auto-jump theo state hiện tại
  const state = scanStateByCh[selectedChannel()] || { prevTotalPages:1, userTouched:false };
  if (totalPages !== state.prevTotalPages) {
    const wasOnLast = (scanPageIndex === state.prevTotalPages) || !state.userTouched;
    scanPageIndex = wasOnLast ? totalPages : Math.min(scanPageIndex, totalPages);
    state.prevTotalPages = totalPages;
  }
  scanPageIndex = Math.min(Math.max(1, scanPageIndex), totalPages);
  scanStateByCh[selectedChannel()] = state;

  // === TÍNH lát cắt (A→Z, trang cuối = phần dư) ===
  const rem = total % PAGE_SIZE;
  const isLast = (scanPageIndex === totalPages);

  let start, end;
  if (rem === 0) {
    // Không dư: mọi trang đều đủ PAGE_SIZE
    start = (scanPageIndex - 1) * PAGE_SIZE;
    end   = scanPageIndex * PAGE_SIZE;
  } else {
    if (isLast) {
      // Last page: chỉ chứa phần dư
      start = total - rem;
      end   = total;
    } else {
      // Các trang trước last: đủ PAGE_SIZE
      start = (scanPageIndex - 1) * PAGE_SIZE;
      end   = scanPageIndex * PAGE_SIZE;
    }
  }

    // Chặn biên
    start = Math.max(0, start);
    end   = Math.min(total, end);

    const slice = rowsFiltered.slice(start, end);

  // Cập nhật UI “current/total”
  if (el2.scanPageDisp) el2.scanPageDisp.textContent = `${scanPageIndex}/${totalPages}`;

  // === Render ===
  if (el2.tblScanBody) {
    el2.tblScanBody.innerHTML = "";
    for (let i = end - 1; i >= start; i--) {
      const [id, ev] = rowsFiltered[i];

      // STT toàn cục đúng, giảm dần: i là index 0-based → STT = i + 1
      const sttGlobal = i + 1;

      const tr = document.createElement("tr");
      const bgClass = (ev.is_cancelled==="Yes" && (ev.time_vn || ev.ts)) ? "bg-yes" : (ev.is_cancelled==="No" ? "bg-no" : "");
      tr.innerHTML = `
        <td>${sttGlobal}</td>
        <td>${id}</td>
        <td>${ev.time_vn || ""}</td>
        <td>${ev.user || ""}</td>
        <td class="${bgClass}">${ev.is_cancelled || "No"}</td>
      `;
      el2.tblScanBody.appendChild(tr);
    }
  }

  // “m/100”

}

// ==== Paging cho bảng Cancel ====
// ==== CANCEL ====
on(el2?.cancelPrev, "click", () => setCancelPage(cancelPageIndex - 1));
on(el2?.cancelNext, "click", () => setCancelPage(cancelPageIndex + 1));
on(el2?.cancelPage, "change", () => setCancelPage(toInt(el2.cancelPage.value)));
on(el2?.cancelPage, "keydown", (e) => { if (e.key === "Enter") setCancelPage(toInt(e.currentTarget.value)); });
on(el2?.cancelPage, "input", () => { userTouchedCancelPage = true; }); // người dùng chỉnh tay

// ===== Render bảng Cancel =====
function renderCancel(){
  const rows = getCancelRows();

  // sort: ưu tiên cancel_time rồi scan_ts (mới → cũ)
  const rowsSorted = applySearch(rows).sort((a,b)=>{
    const A = Number(a[1].cancel_time||0) || Number(a[1].scan_ts||0);
    const B = Number(b[1].cancel_time||0) || Number(b[1].scan_ts||0);
    return B - A;
  });

  const totalPages = Math.max(1, Math.ceil(rowsSorted.length / PAGE_SIZE));
  cancelPageIndex = Math.min(Math.max(1, cancelPageIndex || 1), totalPages);
  if (el2.cancelPageDisp) el2.cancelPageDisp.textContent = `${cancelPageIndex}/${totalPages}`;

  const total = rowsSorted.length;
  const start = (cancelPageIndex - 1) * PAGE_SIZE;
  const slice = rowsSorted.slice(start, start + PAGE_SIZE);

if (el2.tblCancelBody) {
  el2.tblCancelBody.innerHTML = "";
  slice.forEach(([id, ev], idx) => {
    // STT toàn cục giảm dần (mới nhất có số lớn nhất, giống Scan)
    const sttGlobal = total - (start + idx);

    const hasScan = !!(ev.scan_ts || ev.time_vn || ev.user);
    const scanTimeText = hasScan
      ? (ev.time_vn || (ev.scan_ts ? formatISO(ev.scan_ts * 1000) : ""))
      : "";

    const isCanceledAtScan = hasScan ? (ev.is_cancelled || "No") : "";
    const isYes = (isCanceledAtScan === "Yes");
    const isNo  = (isCanceledAtScan === "No");

    const tr = document.createElement("tr");
    const bgClass = isYes ? "bg-yes" : (isNo ? "bg-no" : "");
    tr.innerHTML = `
      <td>${sttGlobal}</td>
      <td>${id}</td>
      <td>${scanTimeText}</td>
      <td>${hasScan ? (ev.user || "") : ""}</td>
      <td class="${bgClass}">${isCanceledAtScan || "-"}</td>
    `;
    el2.tblCancelBody.appendChild(tr);
  });
}

  // Cập nhật header đếm
  const ch = selectedChannel();
  const scanAllCh   = ALL_EVENTS["DATA_SCAN"]?.[ch] || {};
  const cancelSrcCh = ALL_EVENTS["Data-cancel"]?.[ch] || {};
  const totalCancelInScan  = Object.values(scanAllCh).filter(x => x?.is_cancelled === "Yes").length;
  const totalCancelFromSrc = Object.keys(cancelSrcCh).length;
  const cancelHdr = document.getElementById("cancelCountsHdr");
  if (cancelHdr) cancelHdr.textContent = `(${totalCancelInScan} / ${totalCancelFromSrc})`;
}

// Render 2 bảng
function renderBoth(){
  const ch = selectedChannel();

  // dữ liệu theo kênh
  const scanAllCh = ALL_EVENTS["DATA_SCAN"]?.[ch] || {};
  const totalScan = Object.keys(scanAllCh).length;

  // batch hiện tại
  const batchId   = Number(currentBatchByCh[ch] || 1);
  const countCurr = Object.values(scanAllCh).filter(x => x?.batch_id === batchId).length;
  const countPrev = (batchId > 1)
    ? Object.values(scanAllCh).filter(x => x?.batch_id === (batchId - 1)).length
    : 0;

  // chuỗi thống kê cạnh tiêu đề "Scan hôm nay"
  const statsEl = document.getElementById("scanStats");
  if (statsEl) {
    const loopTimes = Math.max(0, (batchId));
    statsEl.innerHTML = [
      `[Tổng: ${totalScan}]`,
      ``,
      `Batch: ${loopTimes}`,
      `-`,
      `Hiện tại: ${countCurr}`,
      `-`,
      `Trước đó: ${countPrev}`,
    ].map(x => `<span>${x}</span>`).join(" ");
  }

  // thống kê hủy
  const cancelSrcCh = ALL_EVENTS["Data-cancel"]?.[ch] || {};
  const totalCancelInScan  = Object.values(scanAllCh).filter(x => x?.is_cancelled==="Yes").length;
  const totalCancelFromSrc = Object.keys(cancelSrcCh).length;
  const cancelCountsHdr = document.getElementById("cancelCountsHdr");
  if (cancelCountsHdr) cancelCountsHdr.textContent = `${totalCancelInScan} / ${totalCancelFromSrc}`;

  // render 2 bảng
  try{ renderScan(); }catch(e){ console.warn("[renderScan] skip:", e); }
  try{ renderCancel(); }catch(e){ console.warn("[renderCancel] skip:", e); }

  // Cập nhật lại pagination buttons sau khi có dữ liệu
  updateScanPagination();
  updateCancelPagination();
}/* === REALTIME LISTENERS === */
let unsubs = { batch: null, data: null, cancel: null };

function listenBatch(dateKey){
  if (unsubs.batch) { unsubs.batch(); unsubs.batch = null; }
  const r = ref(db, `/${dateKey}/BATCH`);
  const cb = snap => { currentBatchByCh = { SPX:1, GHN:1, NJV:1, ...(snap.val()||{}) }; renderBoth(); };
  unsubs.batch = onValue(r, cb);   // onValue v9+ trả về unsubscribe()
}

function listenDataScan(dateKey){
  if (unsubs.data) { unsubs.data(); unsubs.data = null; }
  const r = ref(db, `/${dateKey}/DATA_SCAN`);
  const cb = snap => { ALL_EVENTS.DATA_SCAN = snap.val() || {}; renderBoth(); };
  unsubs.data = onValue(r, cb);
}

function listenCancel(dateKey){
  if (unsubs.cancel) { unsubs.cancel(); unsubs.cancel = null; }
  const r = ref(db, `/${dateKey}/Data-cancel`);
  const cb = snap => {
    const raw = snap.val() || {};
    CANCEL_MAP = {};
    for (const ch of Object.keys(raw||{})) {
      for (const tracking of Object.keys(raw[ch]||{})) {
        const item = raw[ch][tracking];
        if (item && typeof item === "object" && "cancel_time" in item) {
          CANCEL_MAP[tracking.toUpperCase()] = { cancel_time: Number(item.cancel_time)||0, channel: ch };
        }
      }
    }
    ALL_EVENTS["Data-cancel"] = raw; renderBoth();
  };
  unsubs.cancel = onValue(r, cb);
}

function bindAllListenersFor(dateKey){
  listenBatch(dateKey);
  listenDataScan(dateKey);
  listenCancel(dateKey);
}

/* === BINDINGS === */
bindToggle(el.chanGroup, () => {
  // Reset trạng thái userTouched
  const ch = selectedChannel();
  (scanStateByCh[ch] ||= {prevTotalPages:1, userTouched:false}).userTouched = false;

  // Nhảy về last page của channel mới
  const totalPages = getScanTotalPages();
  scanPageIndex   = totalPages;
  const cancelPages = getCancelTotalPages();
  cancelPageIndex = cancelPages;

  renderBoth();
});

const doSearchBoth = () => {
  scanPageIndex = 1;
  cancelPageIndex = 1;
  renderBoth();        // <-- update counters luôn

  // đếm số kết quả tìm thấy
  const q = (el.searchBox.value || "").trim().toUpperCase();
  if (q) {
    const scanMatches   = applySearch(getScanRows()).length;
    const cancelMatches = applySearch(getCancelRows()).length;
    const total = scanMatches + cancelMatches;

    if (total > 0) {
      notice(`🔎 Tìm thấy ${total} kết quả.`, "success", 10000);
    } else {
      notice(`❌ Không tìm thấy đơn nào khớp với "${q}"`, "warning", 10000);
    }
  }
};

el.btnSearch.addEventListener("click", doSearchBoth);
el.searchBox.addEventListener("keydown", e => { if (e.key==="Enter") doSearchBoth(); });

el2.cancelPrev && el2.cancelPrev.addEventListener("click", () => setCancelPage(cancelPageIndex - 1));
el2.cancelNext && el2.cancelNext.addEventListener("click", () => setCancelPage(cancelPageIndex + 1));
// bỏ hẳn mọi tham chiếu tới el2.cancelPage

// ===== Events =====
el.order.addEventListener("keydown", e => { if (e.key === "Enter") submitScan(); });
el.btnNextBatch.addEventListener("click", doNextBatch);

// User
el.user.addEventListener("keydown", e => { if (e.key === "Enter") el.order.focus(); });

// Delete:
el.btnDelete.addEventListener("click", doDelete);
el.deleteBox.addEventListener("keydown", e => { if (e.key==="Enter") doDelete(); });

/* === KHỞI TẠO === */
setInputsEnabled(false);
notice("Đang kết nối Firebase…");
setScanPage(1);
setCancelPage(1);
watchConnectivity();
bindAllListenersFor(SELECTED_KEY);

// Sanity check: log node gốc hôm nay để chắc chắn đúng path
get(ref(db, `/${today()}`)).then(s => console.log("[SNAP today]", today(), s.exists() ? Object.keys(s.val()||{}) : "not-exists"))
.catch(err => console.error("[SNAP today] error", err));
</script>

<!-- SheetJS for Excel export -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

{% endblock %}
