{% extends "home.html" %}
{% block title %}Handover Tool{% endblock %}
{% block content %}
<h1>Handover Tool</h1>

<script>
  window.API_BASE = window.API_BASE || "";   // m·∫∑c ƒë·ªãnh c√πng origin; thay b·∫±ng "http://127.0.0.1:8008" khi dev
</script>

<!-- ===== Controls (m·ªõi) ===== -->
<div id="controls">
  <label>Channel:</label>
  <div id="channelGroup" class="btn-group" data-active="SPX">
    <button type="button" data-val="SPX" class="btn-toggle active">SPX</button>
    <button type="button" data-val="GHN" class="btn-toggle">GHN</button>
  </div>

  <div class="row">
    <input id="userName" placeholder="Nh·∫≠p t√™n ng∆∞·ªùi b√†n giao">
    <input id="orderId" placeholder="Nh·∫≠p m√£ v·∫≠n ƒë∆°n (Enter ƒë·ªÉ Scan)">
    <button id="btnNextBatch" class="btn-action">Next batch</button>
    <button id="btnReport" class="btn-report">Report</button>
  </div>

  <!-- ===== Report + Delete ===== -->
  <div id="reporting">
    <input id="deleteBox" placeholder="Nh·∫≠p m√£ ƒë∆°n c·∫ßn xo√°">
    <button id="btnDelete" class="btn-action btn-danger">Delete</button>
  </div>
</div>

  <!-- Date selector -->
  <div class="row mt-2">
    <label>Ng√†y:</label>
    <input id="datePicker" type="date">
    <input id="searchBox" placeholder="T√¨m theo m√£ ƒë∆°n/user...">
    <button id="btnSearch" class="btn-action">Search</button>
    <button id="btnReset" class="btn-action">Reset</button>
  </div>
</div>

<!-- Inline style removed; using static/css/main.css -->

<!-- ===== Notice ===== -->
<div id="notice" class="notice"></div>

<!-- ===== Dual Tables: Scan (left) & Cancel (right) ===== -->
<div id="tablesWrap">
  <!-- SCAN TABLE -->
  <section id="scanSection">
  <div class="row" style="margin-bottom:6px">
  <h3>
        <!-- SCAN -->
        <span id="scanStats" class="scan-stats"></span>
      </h3>
  <div class="row ml-auto">
        <span>Page:</span>
        <button id="scanPrev">¬´</button>
        <span id="scanPageDisplay">1/1</span>
        <button id="scanNext">¬ª</button>
      </div>
    </div>

    <div class="table-scroll card" style="padding:0">
      <table id="tblScan">
        <thead>
          <tr>
            <th>No.</th>
            <th>M√£ ƒê∆°n</th>
            <th>Scan Time</th>
            <th>User</th>
            <th>Cancel?</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <!-- CANCEL TABLE -->
  <section id="cancelSection">
    <div class="row" style="margin-bottom:6px">
      <h3>
  ƒê∆°n Hu·ª∑ <span id="cancelCountsHdr"></span>
  </h3>
      <div class="row ml-auto">
        <span>Page:</span>
        <button id="cancelPrev">¬´</button>
        <span id="cancelPageDisplay">1/1</span>
        <button id="cancelNext">¬ª</button>
      </div>
    </div>
    <div class="table-scroll card" style="padding:0">
      <table id="tblCancel">
        <thead>
          <tr>
            <th>No.</th>
            <th>M√£ ƒê∆°n</th>
            <th>Scan Time</th>
            <th>User</th>
            <th>Cancel?</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>
</div>

<!-- Inline responsive CSS removed; using static/css/main.css -->

<!-- ===== Firebase SDKs ===== -->
<script type="module">
  // ‚úÖ Ch·ªâ d√πng CDN URL (kh√¥ng d√πng "firebase/database")
  import { initializeApp, getApps } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import {
    getDatabase, ref, get, set, remove, onValue,
    goOffline, goOnline
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCdSInR5JXWsFCZl3ygdoEeSRra6_wGrW4",
    authDomain: "handover-4.firebaseapp.com",
    databaseURL: "https://handover-4-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "handover-4",
    storageBucket: "handover-4.firebasestorage.app",
    messagingSenderId: "935608155206",
    appId: "1:935608155206:web:4abc6a60e1736399571e47",
    measurementId: "G-FVKZLCE7DB"
  };

  // ‚úÖ Tr√°nh l·ªói "Firebase App '[DEFAULT]' already exists"
  const app = getApps().length ? getApps()[0] : initializeApp(firebaseConfig);

  // ‚úÖ DB instance chu·∫©n
  const db = getDatabase(app);

  // (tu·ª≥ ch·ªçn) Ti·∫øt ki·ªám connection khi tab ·∫©n
  document.addEventListener("visibilitychange", () => {
    if (document.hidden) goOffline(db); else goOnline(db);
  });
  window.addEventListener("beforeunload", () => goOffline(db));

  // === Date helpers (GMT+7) ===
  const todayISO = () => {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${dd}`;         // YYYY-MM-DD (cho <input type="date">)
  };
  const isoToKey = (iso) => {
    // YYYY-MM-DD -> DD-MM-YYYY (ƒëang d√πng tr√™n Firebase)
    if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return today(); // fallback
    const [y,m,d] = iso.split("-");
    return `${d}-${m}-${y}`;
  };
  const keyToISO = (key) => {
    // DD-MM-YYYY -> YYYY-MM-DD
    if (!key || !/^\d{2}-\d{2}-\d{4}$/.test(key)) return todayISO();
    const [d,m,y] = key.split("-");
    return `${y}-${m}-${d}`;
  };
  const isSameDay = (isoA, isoB) => isoA === isoB;

  // === Selected day state ===
  const $ = sel => document.querySelector(sel);
  const today = () => {
    const d = new Date();
    const dd = String(d.getDate()).padStart(2,"0");
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const yyyy = d.getFullYear();
    return `${dd}-${mm}-${yyyy}`;
  };
  const formatVN = (d) => {
    // chu·∫©n ho√° GMT+7 b·∫±ng toLocaleString v·ªõi timeZone Asia/Ho_Chi_Minh
    return new Date(d).toLocaleString("vi-VN", { timeZone: "Asia/Ho_Chi_Minh" }).replace(",", "");
  };

  let SELECTED_KEY = today();       // DD-MM-YYYY (ƒë∆∞·ªùng d·∫´n Firebase)
  let SELECTED_ISO = todayISO();    // YYYY-MM-DD (UI date input)

  function formatISO(ts) {
  const d = new Date(ts);
  // bu·ªôc timezone Asia/Ho_Chi_Minh
  const y = d.getFullYear();
  const M = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const hh = String(d.getHours()).padStart(2, "0");
  const mm = String(d.getMinutes()).padStart(2, "0");
  const ss = String(d.getSeconds()).padStart(2, "0");
  return `${y}-${M}-${dd} ${hh}:${mm}:${ss}`;
}

  const notice = (msg, kind="info", timeout=6000) => {
    const bar = $("#notice");
    const styles = {
      info: "color:#31708f;",
      success: "color:#3c763d;font-weight:600;",
      warning: "color:#8a6d3b;font-weight:600;",
      error: "color:#a94442;font-weight:600;"
    };
    bar.style.cssText += styles[kind] || styles.info;
    bar.textContent = msg || "";
    if (timeout>0) setTimeout(()=>bar.textContent="", timeout);
  };

  // ===== State =====
  let ALL_EVENTS = {};     // { DATA_SCAN, Data-cancel }
  let CANCEL_MAP = {};     // TRACKING -> { cancel_time, channel }
  let currentBatchByCh = { SPX:1, GHN:1, NJV:1 };

  // UI refs
  const el = {
    chanGroup: document.getElementById("channelGroup"),
    user: $("#userName"),
    order: $("#orderId"),
    btnNextBatch: $("#btnNextBatch"),
    searchBox: $("#searchBox"),
    btnSearch: $("#btnSearch"),
    deleteBox: $("#deleteBox"),
    btnDelete: $("#btnDelete"),
  };

  // Date picker
  el.datePicker = document.getElementById("datePicker");
  el.btnLoadDay = document.getElementById("btnLoadDay");

  const selectedChannel = () => (el.chanGroup.dataset.active || "SPX");

  function bindToggle(groupEl, onChange){
    groupEl.addEventListener("click", (e)=>{
      const btn = e.target.closest(".btn-toggle");
      if(!btn) return;
      groupEl.querySelectorAll(".btn-toggle").forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      groupEl.dataset.active = btn.dataset.val;
      onChange && onChange();
    });
  }

 // ===== Sound Manager (ƒë·ªçc t·ª´ static/, gi·ªëng v4.5.2) =====
// URL tuy·ªát ƒë·ªëi do Flask build (ƒë√∫ng c·∫£ khi ƒë·ªïi static_url_path).
const STATIC_AUDIO_URLS = {
  "cancel.mp3":      "{{ url_for('static', filename='cancel.mp3') }}",
  "error.mp3":       "{{ url_for('static', filename='error.mp3') }}",
  "ok.mp3":          "{{ url_for('static', filename='ok.mp3') }}",
  "sys_error.mp3":   "{{ url_for('static', filename='sys_error.mp3') }}",
  "sys_success.mp3": "{{ url_for('static', filename='sys_success.mp3') }}"
};

// Map key logic -> file (gi·ªëng tool PC)
const SND_MAP = {
  ok:          "ok.mp3",
  err:         "error.mp3",
  cancel:      "cancel.mp3",
  sys_success: "sys_success.mp3",
  sys_error:   "sys_error.mp3"
};

// Preload
const _audioEls = new Map();
Object.entries(STATIC_AUDIO_URLS).forEach(([name, url]) => {
  const a = new Audio(url);
  a.preload = "auto";
  _audioEls.set(name, a);
});

// Beep fallback ng·∫Øn
const BEEP_OK  = "UklGRoQAAABXQVZFZm10IBAAAAABAAEARKwAABCiAAACABYAAABhYWFhYWFhYQAA";
const BEEP_ERR = "UklGRoQAAABXQVZFZm10IBAAAAABAAEARKwAABCiAAACABYAAABhZmZhZmZhZgAA";
function _beep(ok=true){ const a=new Audio("data:audio/wav;base64,"+(ok?BEEP_OK:BEEP_ERR)); a.play().catch(()=>{}); }

// Reset v·ªÅ m·∫∑c ƒë·ªãnh (SPX / h√¥m nay / page 1)
function resetAll(){
  // reset channel v·ªÅ SPX
  const chGroup = el.chanGroup;
  if (chGroup){
    chGroup.dataset.active = "SPX";
 slice.forEach(([id, ev]) => {
      b.classList.toggle("active", b.dataset.val==="SPX");
    });
  }

  // reset input
  if (el.user) el.user.value = "";
  if (el.order) el.order.value = "";
  if (el.searchBox) el.searchBox.value = "";
  if (el.deleteBox) el.deleteBox.value = "";

  // reset date v·ªÅ h√¥m nay
  SELECTED_ISO = todayISO();
   const tr = document.createElement("tr");
   const bgClass = isYes ? "bg-yes" : (isNo ? "bg-no" : "");
   tr.innerHTML = \`
     <td>${sttGlobal}</td>
     <td>${id}</td>
     <td>${scanTimeText}</td>
     <td>${hasScan ? (ev.user || "") : ""}</td>
     <td class="${bgClass}">${isCanceledAtScan || "-"}</td>
   \`;
  renderBoth();

  // nh·∫£y v·ªÅ trang cu·ªëi c√πng c·ªßa SPX
  const totalPages = getScanTotalPages();
  scanPageIndex = totalPages;
  setScanPage(scanPageIndex);

  const cancelTotalPages = getCancelTotalPages();
  cancelPageIndex = cancelTotalPages;
  setCancelPage(cancelPageIndex);

  // c·∫≠p nh·∫≠t enable/disable theo ng√†y ƒëang ch·ªçn (h√¥m nay) + tr·∫°ng th√°i m·∫°ng
  applyHistoricalMode();

  notice("ƒê√£ reset: Channel SPX / H√¥m nay / Trang cu·ªëi", "success", 4000);
}

const btnReset = document.getElementById("btnReset");
if (btnReset) btnReset.addEventListener("click", resetAll);

// Unlock autoplay (ch·ªâ 1 bi·∫øn)
// Unlock autoplay theo chu·∫©n: ∆∞u ti√™n WebAudio, fallback muted play
let _audioUnlocked = false;

async function unlockAudioOnce() {
  if (_audioUnlocked) return;
  _audioUnlocked = true;

  // 1) ∆Øu ti√™n WebAudio: ph√°t 1 buffer im l·∫∑ng (kh√¥ng ƒë·ª•ng file mp3)
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (AudioCtx) {
      const actx = new AudioCtx();
      if (actx.state === "suspended" && actx.resume) {
        // iOS Safari th∆∞·ªùng c·∫ßn resume trong gesture
        await actx.resume().catch(()=>{});
      }
      const buffer = actx.createBuffer(1, 1, actx.sampleRate); // 1 sample, silence
      const src = actx.createBufferSource();
      src.buffer = buffer;
      src.connect(actx.destination);
      src.start(0);
      return; // xong, ƒë√£ ‚Äúm·ªü kh√≥a‚Äù audio stack
    }
  } catch (e) {
    // ti·∫øp t·ª•c fallback
  }

  // 2) Fallback: play+pause t·∫•t c·∫£ audio nh∆∞ng t·∫Øt ti·∫øng tuy·ªát ƒë·ªëi
  for (const a of _audioEls.values()) {
    try {
      const prevMuted  = a.muted;
      const prevVolume = a.volume;
      a.muted  = true;
      a.volume = 0;
      await a.play().then(()=>a.pause()).catch(()=>{});
      a.currentTime = 0;     // v·ªÅ ƒë·∫ßu
      a.muted  = prevMuted;  // kh√¥i ph·ª•c tr·∫°ng th√°i
      a.volume = prevVolume;
    } catch (e) {}
  }
}

window.addEventListener("click",  unlockAudioOnce, { once: true });
window.addEventListener("keydown", unlockAudioOnce, { once: true });


function playByName(name) {
  const a = _audioEls.get(name);
  if (!a) return _beep(false);
  a.currentTime = 0;
  a.play().catch(()=>{});
}

// H√†m public gi·ªëng v4.5.2
let playOk     = () => playByName(SND_MAP.ok);
let playErr    = () => playByName(SND_MAP.err);
let playCancel = () => playByName(SND_MAP.cancel);
let playSysOk  = () => playByName(SND_MAP.sys_success);
let playSysErr = () => playByName(SND_MAP.sys_error);

// ===== Report (text + file) =====
async function postJSON(url, body){
  const base = (window.API_BASE || "");                 // "" => same origin
  const r = await fetch(base + url, {
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body: JSON.stringify(body)
  });
  if(!r.ok) throw new Error(await r.text());
  return r.json().catch(()=> ({}));
}

// G·ª≠i Report
async function runReport(){
  try{
    // KH√îNG kh√≥a to√†n b·ªô input n·ªØa; ch·ªâ b√°o tr·∫°ng th√°i
    notice("ƒêang th·ª±c hi·ªán Report (text + file)‚Ä¶");
    const res = await postJSON("/api/report/run", { date: SELECTED_KEY }); // d√πng ng√†y ƒëang ch·ªçn
    playSysOk();
    const link = (res && res.seatalk && res.seatalk.file_url) ? res.seatalk.file_url : "";
    notice(`‚úÖ ƒê√£ g·ª≠i Report cho ng√†y ${SELECTED_KEY} qua Seatalk - nh√≥m Handover`, "success", 10000);
  }catch(e){
    playSysErr();
    notice("‚ùå Report l·ªói: " + e.message, "error", 10000);
  }
}

document.getElementById("btnReport").addEventListener("click", runReport);

function applyHistoricalMode(){
  const isToday = isSameDay(SELECTED_ISO, todayISO());

  // Cho ph√©p Search + Report m·ªçi l√∫c
  el.searchBox.disabled = false;
  el.btnSearch.disabled = false;
  document.getElementById("btnReport").disabled = false;

  // N·∫øu KH√îNG ph·∫£i h√¥m nay -> kh√≥a c√°c t√°c v·ª• ghi
  const lock = !isToday || !connected;
  // Scan + Delete + Next batch
  el.order.disabled = lock;
  el.btnDelete.disabled = lock;
  el.deleteBox.disabled = lock;
  el.btnNextBatch.disabled = lock;

  // Nh√≥m toggle channel/mode v√† paging v·∫´n b·∫≠t ƒë·ªÉ duy·ªát d·ªØ li·ªáu
  el.chanGroup?.querySelectorAll("button").forEach(b => b.disabled = false);
  el.modeGroup?.querySelectorAll("button").forEach(b => b.disabled = false);

  if (el.btnPrev) el.btnPrev.disabled = false;
  if (el.btnNext) el.btnNext.disabled = false;
  if (el.page)    el.page.disabled    = false;


  // Th√¥ng b√°o
  if (!isToday) {
    notice(`ƒêang xem d·ªØ li·ªáu ng√†y ${SELECTED_KEY}. Ch·∫ø ƒë·ªô ch·ªâ ƒë·ªçc (Search/Report).`, "warning", 6000);
  }
}

// Auto-load khi ƒë·ªïi ng√†y tr√™n datePicker
el.datePicker.addEventListener("change", () => {
  const pickISO = el.datePicker.value || todayISO();

  // N·∫øu kh√¥ng ƒë·ªïi ng√†y th√¨ th√¥i
  if (pickISO === SELECTED_ISO) return;

  // C·∫≠p nh·∫≠t state ng√†y
  SELECTED_ISO = pickISO;
  SELECTED_KEY = isoToKey(pickISO);

  // Reset paging v·ªÅ trang 1 cho c·∫£ hai b·∫£ng
  scanPageIndex = 1;
  cancelPageIndex = 1;
  setScanPage(1);
  setCancelPage(1);

  // G·∫Øn l·∫°i listeners theo ng√†y m·ªõi
  bindAllListenersFor(SELECTED_KEY);
  // B·∫≠t/t·∫Øt input theo ng√†y & m·∫°ng
  applyHistoricalMode();
  // Render l·∫°i
  renderBoth();
});

// Khi tr·∫°ng th√°i k·∫øt n·ªëi ƒë·ªïi, v·∫´n gi·ªØ nguy√™n rule theo ng√†y
const _origWatchConnectivity = watchConnectivity;

el.datePicker.value = SELECTED_ISO;
let pageIndex = 1;
let connected = false;

  // ch·ªëng spam & tr√πng trong phi√™n
  let isSubmitting = false;
  const PENDING_SET = new Set();              // id ƒëang submit (ch∆∞a xong)
  const LOCAL_SEEN  = new Map();              // key = `${today()}|${ch}` -> Set(ids)

  function _seenKey(ch){ return `${today()}|${ch}`; }
  function _getSeen(ch){
    const k = _seenKey(ch);
    if (!LOCAL_SEEN.has(k)) LOCAL_SEEN.set(k, new Set());
    return LOCAL_SEEN.get(k);
}

  const setInputsEnabled = (on) => {
  const disabled = !on;
  [el.order, el.btnNextBatch,el.searchBox, el.btnSearch, el.deleteBox, el.btnDelete].forEach(x => x && (x.disabled = disabled));

  // disable c√°c n√∫t trong nh√≥m toggle
  el.chanGroup?.querySelectorAll("button").forEach(b => b.disabled = disabled);
};

// ===== B·∫ÆT L·ªñI TO√ÄN C·ª§C + D·∫§U V·∫æT BOOT =====
console.log("[BOOT] handover module start");
window.addEventListener("error", e => console.error("[GlobalError]", e.message, e.filename, e.lineno, e.error));
window.addEventListener("unhandledrejection", e => console.error("[PromiseRejection]", e.reason));

// üîå Theo d√µi k·∫øt n·ªëi Firebase (bao g·ªìm m·∫•t m·∫°ng)
// ‚úÖ d√πng function declaration ƒë·ªÉ ƒë∆∞·ª£c hoisted
// ---- helpers ----
function pick(...ids){
  for (const id of ids){
    const el = document.getElementById(id);
    if (el) return el;
  }
  return null;
}

// ---- functions (d√πng function declaration ƒë·ªÉ hoisted) ----
function watchConnectivity() {
  const infoRef = ref(db, ".info/connected");
  onValue(infoRef, snap => {
    connected = !!snap.val();
    if (!connected) notice("M·∫•t k·∫øt n·ªëi Firebase. Vui l√≤ng ki·ªÉm tra m·∫°ng‚Ä¶", "error", 0);
    else notice("ƒê√£ k·∫øt n·ªëi Firebase.", "success", 1500);
    applyHistoricalMode();
  });
}

/* ==== RENDER & DATA HELPERS ==== */
const PAGE_SIZE = 100;

// hoist 1 l·∫ßn ·ªü tr√™n
function parseTimeString(s){
  try{
    const str = String(s||"").trim();

    // ISO-like: YYYY-MM-DD HH:mm:ss
    let m = str.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
    if (m) {
      const [_, y, M, d, h, m1, s1] = m.map(Number);
      return Math.floor(new Date(y, M-1, d, h, m1, s1).getTime()/1000);
    }

    // VN-like: DD-MM-YYYY HH:mm:ss
    m = str.match(/^(\d{2})-(\d{2})-(\d{4})[ T](\d{2}):(\d{2}):(\d{2})$/);
    if (m) {
      const [_, d, M, y, h, m1, s1] = m.map(Number);
      return Math.floor(new Date(y, M-1, d, h, m1, s1).getTime()/1000);
    }
  }catch(e){/* no-op */}
  return 0;
}

// helper chung
function paginate(total, pageSize, reqPage){
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  const page = Math.min(Math.max(1, Number(reqPage || 1)), totalPages);
  const start = (page - 1) * pageSize;          // 0-based
  const end   = Math.min(start + pageSize, total);
  const count = end - start;                     // s·ªë d√≤ng th·ª±c s·ª± hi·ªÉn th·ªã
  const noStart = total - start;                 // STT ƒë·∫ßu trang (gi·∫£m d·∫ßn)
  return { totalPages, page, start, end, count, noStart };
}

function getScanRows(){
  const ch = selectedChannel();
  const data = (ALL_EVENTS["DATA_SCAN"]?.[ch]) || {};
  const rows = [];
  for (const [id, v] of Object.entries(data)){
    let ts = Number(v.ts||0);
    if (!ts && v.time) ts = parseTimeString(v.time);
    rows.push([id, {
      ts,                                  // scan_ts
      time_vn: v.time_vn || v.time || (ts ? formatISO(ts*1000) : ""),
      user: v.user || "",
      is_cancelled: v.is_cancelled || "No",
      batch_id: v.batch_id || "",
    }]);
  }
  return rows;
}

function getScanTotalPages(){
  const rows = (typeof applySearch==="function") ? applySearch(getScanRows()) : getScanRows();
  return Math.max(1, Math.ceil(rows.length / PAGE_SIZE));
}

function getCancelRows(){
  const ch = selectedChannel();
  const cancelSrc = (ALL_EVENTS["Data-cancel"]?.[ch]) || {};
  const scanData  = (ALL_EVENTS["DATA_SCAN"]?.[ch]) || {};

  const rows = [];
  for (const id of Object.keys(cancelSrc)) {
    const evScan = scanData[id] || {};   // n·∫øu ch∆∞a scan th√¨ object r·ªóng
    let scan_ts = Number(evScan.ts||0);
    if (!scan_ts && evScan.time) scan_ts = parseTimeString(evScan.time);

    rows.push([id, {
      cancel_time: Number(cancelSrc[id]?.cancel_time) || 0,
      scan_ts,
      time_vn: evScan.time_vn || evScan.time || "",
      user: evScan.user || "",
      // ‚úÖ ch·ªâ l·∫•y is_cancelled n·∫øu c√≥ b·∫£n ghi SCAN, n·∫øu ch∆∞a scan => ƒë·ªÉ ""
      is_cancelled: (Object.keys(evScan).length > 0) ? (evScan.is_cancelled || "No") : "",
      batch_id: evScan.batch_id || "",
    }]);
  }
  return rows;
}

function applySearch(rows){
  const q = (el.searchBox.value || "").trim().toUpperCase();
  if (!q) return rows;
  return rows.filter(([id, ev]) =>
    id.toUpperCase().includes(q) ||
    (ev.user||"").toUpperCase().includes(q)
  );
}

/* =========================
   RENDER 2 B·∫¢NG
========================= */
const el2 = {
  tblScanBody   : document.querySelector("#tblScan tbody"),
  tblCancelBody : document.querySelector("#tblCancel tbody"),
  scanPrev      : document.getElementById("scanPrev"),
  scanNext      : document.getElementById("scanNext"),
  cancelPrev    : document.getElementById("cancelPrev"),
  cancelNext    : document.getElementById("cancelNext"),
  scanPageDisp  : document.getElementById("scanPageDisplay"),
  cancelPageDisp: document.getElementById("cancelPageDisplay"),
};

let scanPageIndex   = 1;
let cancelPageIndex = 1;

const currentBatch = () => Number(currentBatchByCh[selectedChannel()] || 1);

// ===== Submit scan (GMT+7 + sound + prefix) =====
  const prefixByCh = {
  SPX: { prefix: "SPX", len: 17 },   // 3 + 14 k√Ω t·ª±
  GHN: { prefix: "G",   len: 8  },   // 1 + 7 k√Ω t·ª±
  NJV: { prefix: "SPE", len: null }  // ch∆∞a gi·ªõi h·∫°n
};

  const submitScan = async () => {
    if (!connected) { playErr(); notice("Ch∆∞a k·∫øt n·ªëi Firebase!", "error", 3000); return; }

    const user = (el.user.value || "").trim();
    const id   = (el.order.value || "").trim().toUpperCase();
    const ch   = selectedChannel();

    if (!user) {
      playErr();
      notice("‚ö†Ô∏è T√™n ng∆∞·ªùi b√†n giao kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng!", "warning", 3000);
      el.order.value = "";
      el.user.focus();
      return;
    }
    if (!id) return;

    const rule = prefixByCh[ch] || {};
    const prefix = rule.prefix || "";
    const maxLen = rule.len;

    // check prefix
    if (!id.startsWith(prefix)) {
      playErr();
      notice(`‚ùó ƒê∆°n ${id} kh√¥ng thu·ªôc Channel ${ch}.`, "error", 3000);
      el.order.value = "";
      el.order.focus();
      return;
    }

    // check length n·∫øu c√≥ quy ƒë·ªãnh
    if (maxLen && id.length > maxLen) {
      playErr();
      notice(`‚ùó ${ch} ch·ªâ cho ph√©p t·ªëi ƒëa ${maxLen} k√Ω t·ª± (hi·ªán ${id.length}).`, "error", 3000);
      el.order.value = "";
      el.order.focus();
      return;
    }

    const node = `/${today()}/DATA_SCAN/${ch}/${id}`;
    const snap = await get(ref(db, node));
    if (snap.exists()) {
      playErr();
      notice(`‚ùó ƒê∆°n ${id} ƒë√£ ƒë∆∞·ª£c qu√©t tr∆∞·ªõc ƒë√≥.`, "warning", 3000);
      el.order.value = "";
      el.order.focus();
      return;
    }

    // CANCEL check
    const isCancelled = (CANCEL_MAP[id]?.channel?.toUpperCase() === ch) ? "Yes" : "No";
    const nowTs = Math.floor(Date.now()/1000);
    const payload = {
      ts: nowTs,                                      // epoch seconds (ƒë·ªÉ sort)
      // time_vn: formatVN(nowTs*1000),                  // hi·ªÉn th·ªã chu·∫©n GMT+7
      time_vn: formatISO(nowTs*1000),                 // hi·ªÉn th·ªã chu·∫©n YYYY-MM-DD HH:mm:ss
      user,
      is_cancelled: isCancelled,
      source: "webapp",
      batch_id: currentBatch()
    };
    await set(ref(db, node), payload);

    if (isCancelled==="Yes") {
    playCancel();                             // ‚¨ÖÔ∏è thay v√¨ playErr()
    notice(`${id} - ƒê∆†N CANCEL`, "warning", 6000);
    } else {
      playOk();
      notice(`‚úÖ ${id}`, "success", 1500);
    }
    el.order.focus();
    el.order.value = "";
  };

  // ===== Next batch =====
  const doNextBatch = async () => {
    if (!connected) { playErr(); notice("Ch∆∞a k·∫øt n·ªëi Firebase!", "error", 3000); return; }
    const ch = selectedChannel();
    const node = `/${today()}/BATCH/${ch}`;
    const cur  = (await get(ref(db, node))).val() || 1;
    await set(ref(db, node), Number(cur)+1);
    el.order.focus();
  };

  // ===== Delete =====
  const doDelete = async () => {
    if (!connected) {
      playErr();
      notice("Ch∆∞a k·∫øt n·ªëi Firebase!", "error", 3000);
      return;
    }

    const id = (el.deleteBox.value||"").trim().toUpperCase();
    if (!id) return;

    const ch = selectedChannel();
    const node = `/${today()}/DATA_SCAN/${ch}/${id}`;
    const snap = await get(ref(db, node));

    // 1. N·∫øu kh√¥ng c√≥ ƒë∆°n => b√°o lu√¥n
    if (!snap.exists()) {
      playErr();
      notice(`Kh√¥ng t√¨m th·∫•y ƒë∆°n ${id} ƒë·ªÉ xo√°.`, "warning", 2500);
      el.deleteBox.value = "";
      return;
    }

    // 2. N·∫øu c√≥ ƒë∆°n => popup confirm
    if (!window.confirm(`B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën xo√° ƒë∆°n ${id}?`)) {
      return; // user Cancel th√¨ th√¥i
    }

    // 3. Th·ª±c hi·ªán xo√°
    await remove(ref(db, node));
    playOk();
    notice(`üóëÔ∏è ƒê√£ xo√° ${id}`, "success", 2000);
    el.deleteBox.value = "";
  };

// state
const scanStateByCh = {
  SPX: { prevTotalPages: 1, userTouched: false },
  GHN: { prevTotalPages: 1, userTouched: false },
};

// helper
const on = (el, ev, fn) => el && el.addEventListener(ev, fn);
const toInt = v => Math.max(1, parseInt(v, 10) || 1);

// Scan
function setScanPage(n){
  const totalPages = getScanTotalPages();
  scanPageIndex = Math.min(Math.max(1, Number(n)||1), totalPages);
  if (el2.scanPageDisp) el2.scanPageDisp.textContent = `${scanPageIndex}/${totalPages}`;
  renderScan();
}
on(el2?.scanPrev, "click", () => setScanPage(scanPageIndex - 1));
on(el2?.scanNext, "click", () => setScanPage(scanPageIndex + 1));

// Cancel
function getCancelTotalPages(){
  const totalRows = getCancelRows().length;
  return Math.max(1, Math.ceil(totalRows / PAGE_SIZE));
}
function setCancelPage(n){
  const totalPages = getCancelTotalPages();
  cancelPageIndex = Math.min(Math.max(1, Number(n)||1), totalPages);
  if (el2.cancelPageDisp) el2.cancelPageDisp.textContent = `${cancelPageIndex}/${totalPages}`;
  renderCancel();
}
on(el2?.cancelPrev, "click", () => setCancelPage(cancelPageIndex - 1));
on(el2?.cancelNext, "click", () => setCancelPage(cancelPageIndex + 1));
console.log('scanPrev:', !!el2?.scanPrev, 'scanNext:', !!el2?.scanNext);

// ===== Render b·∫£ng Scan =====

// T√≠nh l√°t c·∫Øt
function scanSliceBounds(total, pageSize, pageIndex){
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  const rem = total % pageSize;

  // Kh√¥ng d∆∞: c√°c trang ƒë·ªÅu ƒë·ªß pageSize
  if (rem === 0) {
    const end   = pageIndex * pageSize;
    const start = end - pageSize;
    return { start, end };
  }

  // C√≥ d∆∞: last page (page = totalPages) l√† ph·∫ßn d∆∞ (rem),
  // c√°c trang tr∆∞·ªõc ƒë√≥ ƒë·ªÅu ƒë·ªß pageSize v√† n·∫±m TR∆Ø·ªöC ph·∫ßn d∆∞.
  if (pageIndex === totalPages) {
    const start = total - rem;
    const end   = total;
    return { start, end };
  } else {
    // S·ªë trang n·∫±m "sau" trang hi·ªán t·∫°i (t√≠nh t·ªõi last page)
    const blocksAfter = (totalPages - pageIndex);
    const end   = total - rem - (blocksAfter - 0) * pageSize; // ho·∫∑c: total - rem - (blocksAfter * pageSize)
    const start = end - pageSize;
    return { start, end };
  }
}

function renderScan(){
  const rows = getScanRows();
  const rowsFiltered = (typeof applySearch==="function") ? applySearch(rows) : rows;

  // === Sort A‚ÜíZ (c≈© ‚Üí m·ªõi) ƒë·ªÉ ƒëu√¥i l√† m·ªõi nh·∫•t ===
  rowsFiltered.sort((a,b)=>{
    const tsA = Number(a[1].ts||0) || parseTimeString(a[1].time_vn) || parseTimeString(a[1].time);
    const tsB = Number(b[1].ts||0) || parseTimeString(b[1].time_vn) || parseTimeString(b[1].time);
    return tsA - tsB;  // A‚ÜíZ
  });

  const total = rowsFiltered.length;
  const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));

  // c·∫≠p nh·∫≠t auto-jump theo state hi·ªán t·∫°i
  const state = scanStateByCh[selectedChannel()] || { prevTotalPages:1, userTouched:false };
  if (totalPages !== state.prevTotalPages) {
    const wasOnLast = (scanPageIndex === state.prevTotalPages) || !state.userTouched;
    scanPageIndex = wasOnLast ? totalPages : Math.min(scanPageIndex, totalPages);
    state.prevTotalPages = totalPages;
  }
  scanPageIndex = Math.min(Math.max(1, scanPageIndex), totalPages);
  scanStateByCh[selectedChannel()] = state;

  // === T√çNH l√°t c·∫Øt (A‚ÜíZ, trang cu·ªëi = ph·∫ßn d∆∞) ===
  const rem = total % PAGE_SIZE;
  const isLast = (scanPageIndex === totalPages);

  let start, end;
  if (rem === 0) {
    // Kh√¥ng d∆∞: m·ªçi trang ƒë·ªÅu ƒë·ªß PAGE_SIZE
    start = (scanPageIndex - 1) * PAGE_SIZE;
    end   = scanPageIndex * PAGE_SIZE;
  } else {
    if (isLast) {
      // Last page: ch·ªâ ch·ª©a ph·∫ßn d∆∞
      start = total - rem;
      end   = total;
    } else {
      // C√°c trang tr∆∞·ªõc last: ƒë·ªß PAGE_SIZE
      start = (scanPageIndex - 1) * PAGE_SIZE;
      end   = scanPageIndex * PAGE_SIZE;
    }
  }

    // Ch·∫∑n bi√™n
    start = Math.max(0, start);
    end   = Math.min(total, end);

    const slice = rowsFiltered.slice(start, end);

  // C·∫≠p nh·∫≠t UI ‚Äúcurrent/total‚Äù
  if (el2.scanPageDisp) el2.scanPageDisp.textContent = `${scanPageIndex}/${totalPages}`;

  // === Render ===
  el2.tblScanBody.innerHTML = "";
  for (let i = end - 1; i >= start; i--) {
    const [id, ev] = rowsFiltered[i];

    // STT to√†n c·ª•c ƒë√∫ng, gi·∫£m d·∫ßn: i l√† index 0-based ‚Üí STT = i + 1
    const sttGlobal = i + 1;

    const tr = document.createElement("tr");
    const bgClass = (ev.is_cancelled==="Yes" && (ev.time_vn || ev.ts)) ? "bg-yes" : (ev.is_cancelled==="No" ? "bg-no" : "");
    tr.innerHTML = `
      <td>${sttGlobal}</td>
      <td>${id}</td>
      <td>${ev.time_vn || ""}</td>
      <td>${ev.user || ""}</td>
      <td class="${bgClass}">${ev.is_cancelled || "No"}</td>
    `;
    el2.tblScanBody.appendChild(tr);
  };

  // ‚Äúm/100‚Äù
  const scanShowEl = document.getElementById("scanShow");
  if (scanShowEl) scanShowEl.textContent = `${slice.length}/${PAGE_SIZE}`;
}

// ==== Paging cho b·∫£ng Cancel ====
// ==== CANCEL ====
on(el2?.cancelPrev, "click", () => setCancelPage(cancelPageIndex - 1));
on(el2?.cancelNext, "click", () => setCancelPage(cancelPageIndex + 1));
on(el2?.cancelPage, "change", () => setCancelPage(toInt(el2.cancelPage.value)));
on(el2?.cancelPage, "keydown", (e) => { if (e.key === "Enter") setCancelPage(toInt(e.currentTarget.value)); });
on(el2?.cancelPage, "input", () => { userTouchedCancelPage = true; }); // ng∆∞·ªùi d√πng ch·ªânh tay

// ===== Render b·∫£ng Cancel =====
function renderCancel(){
  const rows = getCancelRows();

  // sort: ∆∞u ti√™n cancel_time r·ªìi scan_ts (m·ªõi ‚Üí c≈©)
  const rowsSorted = applySearch(rows).sort((a,b)=>{
    const A = Number(a[1].cancel_time||0) || Number(a[1].scan_ts||0);
    const B = Number(b[1].cancel_time||0) || Number(b[1].scan_ts||0);
    return B - A;
  });

  const totalPages = Math.max(1, Math.ceil(rowsSorted.length / PAGE_SIZE));
  cancelPageIndex = Math.min(Math.max(1, cancelPageIndex || 1), totalPages);
  if (el2.cancelPageDisp) el2.cancelPageDisp.textContent = `${cancelPageIndex}/${totalPages}`;

  const total = rowsSorted.length;
  const start = (cancelPageIndex - 1) * PAGE_SIZE;
  const slice = rowsSorted.slice(start, start + PAGE_SIZE);

el2.tblCancelBody.innerHTML = "";
slice.forEach(([id, ev], idx) => {
  // STT to√†n c·ª•c gi·∫£m d·∫ßn (m·ªõi nh·∫•t c√≥ s·ªë l·ªõn nh·∫•t, gi·ªëng Scan)
  const sttGlobal = total - (start + idx);

  const hasScan = !!(ev.scan_ts || ev.time_vn || ev.user);
  const scanTimeText = hasScan
    ? (ev.time_vn || (ev.scan_ts ? formatISO(ev.scan_ts * 1000) : ""))
    : "";

  const isCanceledAtScan = hasScan ? (ev.is_cancelled || "No") : "";
  const isYes = (isCanceledAtScan === "Yes");
  const isNo  = (isCanceledAtScan === "No");

  const tr = document.createElement("tr");
  const bgClass = isYes ? "bg-yes" : (isNo ? "bg-no" : "");
  tr.innerHTML = `
    <td>${sttGlobal}</td>
    <td>${id}</td>
    <td>${scanTimeText}</td>
    <td>${hasScan ? (ev.user || "") : ""}</td>
    <td class="${bgClass}">${isCanceledAtScan || "-"}</td>
  `;
  el2.tblCancelBody.appendChild(tr);
});

  // C·∫≠p nh·∫≠t header ƒë·∫øm
  const ch = selectedChannel();
  const scanAllCh   = ALL_EVENTS["DATA_SCAN"]?.[ch] || {};
  const cancelSrcCh = ALL_EVENTS["Data-cancel"]?.[ch] || {};
  const totalCancelInScan  = Object.values(scanAllCh).filter(x => x?.is_cancelled === "Yes").length;
  const totalCancelFromSrc = Object.keys(cancelSrcCh).length;
  const cancelHdr = document.getElementById("cancelCountsHdr");
  if (cancelHdr) cancelHdr.textContent = `(${totalCancelInScan} / ${totalCancelFromSrc})`;
}

// Render 2 b·∫£ng
function renderBoth(){
  const ch = selectedChannel();

  // d·ªØ li·ªáu theo k√™nh
  const scanAllCh = ALL_EVENTS["DATA_SCAN"]?.[ch] || {};
  const totalScan = Object.keys(scanAllCh).length;

  // batch hi·ªán t·∫°i
  const batchId   = Number(currentBatchByCh[ch] || 1);
  const countCurr = Object.values(scanAllCh).filter(x => x?.batch_id === batchId).length;
  const countPrev = (batchId > 1)
    ? Object.values(scanAllCh).filter(x => x?.batch_id === (batchId - 1)).length
    : 0;

  // chu·ªói th·ªëng k√™ c·∫°nh ti√™u ƒë·ªÅ "Scan h√¥m nay"
  const statsEl = document.getElementById("scanStats");
  if (statsEl) {
    const loopTimes = Math.max(0, (batchId));
    statsEl.innerHTML = [
      `[T·ªïng: ${totalScan}]`,
      ``,
      `Batch: ${loopTimes}`,
      `-`,
      `Hi·ªán t·∫°i: ${countCurr}`,
      `-`,
      `Tr∆∞·ªõc ƒë√≥: ${countPrev}`,
    ].map(x => `<span>${x}</span>`).join(" ");
  }

  // th·ªëng k√™ h·ªßy
  const cancelSrcCh = ALL_EVENTS["Data-cancel"]?.[ch] || {};
  const totalCancelInScan  = Object.values(scanAllCh).filter(x => x?.is_cancelled==="Yes").length;
  const totalCancelFromSrc = Object.keys(cancelSrcCh).length;
  document.getElementById("cancelCountsHdr").textContent = `${totalCancelInScan} / ${totalCancelFromSrc}`;

  // render 2 b·∫£ng
  try{ renderScan(); }catch(e){ console.warn("[renderScan] skip:", e); }
  try{ renderCancel(); }catch(e){ console.warn("[renderCancel] skip:", e); }
}

/* === REALTIME LISTENERS === */
let unsubs = { batch: null, data: null, cancel: null };

function listenBatch(dateKey){
  if (unsubs.batch) { unsubs.batch(); unsubs.batch = null; }
  const r = ref(db, `/${dateKey}/BATCH`);
  const cb = snap => { currentBatchByCh = { SPX:1, GHN:1, NJV:1, ...(snap.val()||{}) }; renderBoth(); };
  unsubs.batch = onValue(r, cb);   // onValue v9+ tr·∫£ v·ªÅ unsubscribe()
}

function listenDataScan(dateKey){
  if (unsubs.data) { unsubs.data(); unsubs.data = null; }
  const r = ref(db, `/${dateKey}/DATA_SCAN`);
  const cb = snap => { ALL_EVENTS.DATA_SCAN = snap.val() || {}; renderBoth(); };
  unsubs.data = onValue(r, cb);
}

function listenCancel(dateKey){
  if (unsubs.cancel) { unsubs.cancel(); unsubs.cancel = null; }
  const r = ref(db, `/${dateKey}/Data-cancel`);
  const cb = snap => {
    const raw = snap.val() || {};
    CANCEL_MAP = {};
    for (const ch of Object.keys(raw||{})) {
      for (const tracking of Object.keys(raw[ch]||{})) {
        const item = raw[ch][tracking];
        if (item && typeof item === "object" && "cancel_time" in item) {
          CANCEL_MAP[tracking.toUpperCase()] = { cancel_time: Number(item.cancel_time)||0, channel: ch };
        }
      }
    }
    ALL_EVENTS["Data-cancel"] = raw; renderBoth();
  };
  unsubs.cancel = onValue(r, cb);
}

function bindAllListenersFor(dateKey){
  listenBatch(dateKey);
  listenDataScan(dateKey);
  listenCancel(dateKey);
}


/* === BINDINGS === */
bindToggle(el.chanGroup, () => {
  // Reset tr·∫°ng th√°i userTouched
  const ch = selectedChannel();
  (scanStateByCh[ch] ||= {prevTotalPages:1, userTouched:false}).userTouched = false;

  // Nh·∫£y v·ªÅ last page c·ªßa channel m·ªõi
  const totalPages = getScanTotalPages();
  scanPageIndex   = totalPages;
  const cancelPages = getCancelTotalPages();
  cancelPageIndex = cancelPages;

  renderBoth();
});

const doSearchBoth = () => {
  scanPageIndex = 1;
  cancelPageIndex = 1;
  renderBoth();        // <-- update counters lu√¥n

  // ƒë·∫øm s·ªë k·∫øt qu·∫£ t√¨m th·∫•y
  const q = (el.searchBox.value || "").trim().toUpperCase();
  if (q) {
    const scanMatches   = applySearch(getScanRows()).length;
    const cancelMatches = applySearch(getCancelRows()).length;
    const total = scanMatches + cancelMatches;

    if (total > 0) {
      notice(`üîé T√¨m th·∫•y ${total} k·∫øt qu·∫£.`, "success", 10000);
    } else {
      notice(`‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n n√†o kh·ªõp v·ªõi "${q}"`, "warning", 10000);
    }
  }
};

el.btnSearch.addEventListener("click", doSearchBoth);
el.searchBox.addEventListener("keydown", e => { if (e.key==="Enter") doSearchBoth(); });

el2.cancelPrev && el2.cancelPrev.addEventListener("click", () => setCancelPage(cancelPageIndex - 1));
el2.cancelNext && el2.cancelNext.addEventListener("click", () => setCancelPage(cancelPageIndex + 1));
// b·ªè h·∫≥n m·ªçi tham chi·∫øu t·ªõi el2.cancelPage

// ===== Events =====
el.order.addEventListener("keydown", e => { if (e.key === "Enter") submitScan(); });
el.btnNextBatch.addEventListener("click", doNextBatch);

// User
el.user.addEventListener("keydown", e => { if (e.key === "Enter") el.order.focus(); });

// Delete:
el.btnDelete.addEventListener("click", doDelete);
el.deleteBox.addEventListener("keydown", e => { if (e.key==="Enter") doDelete(); });

/* === KH·ªûI T·∫†O === */
setInputsEnabled(false);
notice("ƒêang k·∫øt n·ªëi Firebase‚Ä¶");
setScanPage(1);
setCancelPage(1);
watchConnectivity();
bindAllListenersFor(SELECTED_KEY);

// Sanity check: log node g·ªëc h√¥m nay ƒë·ªÉ ch·∫Øc ch·∫Øn ƒë√∫ng path
get(ref(db, `/${today()}`)).then(s => console.log("[SNAP today]", today(), s.exists() ? Object.keys(s.val()||{}) : "not-exists"))
.catch(err => console.error("[SNAP today] error", err));
</script>

{% endblock %}
